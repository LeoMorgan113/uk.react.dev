---
title: Рендер і коміт
---

<Intro>

Перш ніж ваші компоненти відобразяться на екрані, їх повинен відрендерити React. Розуміння кроків цього процесу допоможе осмислити перебіг виконання вашого коду та пояснити його поведінку.

</Intro>

<YouWillLearn>

* Що таке рендеринг у React
* Коли і чому React рендерить компонент
* Кроки відображення компонента на екрані
* Чому рендеринг не завжди призводить до оновлення DOM

</YouWillLearn>

Уявіть, що ваші компоненти — це кухарі на кухні, які створюють смачні страви з інгредієнтів. У такій історії React — це офіціант, який приймає від клієнтів замовлення та видає їм їжу. Цей процес замовлення та видавання UI складається з трьох кроків:

1. **Тригер** рендеру (доставлення замовлення гостя на кухню)
2. **Рендер** компонента (готування замовлення на кухні)
3. **Коміт** у DOM (розміщення замовлення на столі гостя)

<IllustrationBlock sequential>
  <Illustration caption="Тригер" alt="React як офіціант у ресторані, що збирає замовлення від клієнтів і передає їх до кухні компонентів (Component Kitchen)." src="/images/docs/illustrations/i_render-and-commit1.png" />
  <Illustration caption="Рендер" alt="Кухар карток видає React свіжий компонент картки (Card)." src="/images/docs/illustrations/i_render-and-commit2.png" />
  <Illustration caption="Коміт" alt="React доставляє картку (Card) клієнту на стіл." src="/images/docs/illustrations/i_render-and-commit3.png" />
</IllustrationBlock>

## Крок 1: Тригер рендеру {/*step-1-trigger-a-render*/}

Існує дві причини для рендерингу компонента:

1. Це **початковий рендер** компонента.
2. **Було оновлено стан** компонента (або одного з його предків).

### Початковий рендер {/*initial-render*/}

Під час запуску застосунку необхідно викликати початковий рендер. Фреймворки та пісочниці іноді приховують цей код, але це насправді виклик [`createRoot`](/reference/react-dom/client/createRoot) із передачею цільового вузла DOM і потім виклик методу `render` із вашим компонентом:

<Sandpack>

```js src/index.js active
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

```js src/Image.js
export default function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Рід квіткові' ('Floralis Genérica') — Едуардо Каталано (Eduardo Catalano): велетенська металева скульптура квітки зі світловідбивними пелюстками"
    />
  );
}
```

</Sandpack>

Спробуйте зробити `root.render()` коментарем — і побачите, що компонент зник!

### Повторний рендер під час оновлення стану {/*re-renders-when-state-updates*/}

Після першого рендеру компонента ви можете збудити (trigger) подальші рендери, оновивши його стан за допомогою [функції `set`.](/reference/react/useState#setstate) Оновлення стану вашого компонента автоматично додає рендер до черги. (Уявіть відвідувача ресторану, який після першого замовлення замовляє чай, десерт та всяку всячину залежно від стану спраги чи голоду).

<IllustrationBlock sequential>
  <Illustration caption="Оновлення стану..." alt="React як офіціант у ресторані, що подає клієнту, представленому як постать з курсором замість голови, інтерфейс карти (Card UI). Постать бажає рожеву картку, а не чорну!" src="/images/docs/illustrations/i_rerender1.png" />
  <Illustration caption="...збуджує..." alt="React повертається до кухні компонентів (Component Kitchen) і каже кухареві карток, що потрібна рожева картка (Card)." src="/images/docs/illustrations/i_rerender2.png" />
  <Illustration caption="...рендер!" alt="Кухар карток видає React рожеву картку (Card)." src="/images/docs/illustrations/i_rerender3.png" />
</IllustrationBlock>

## Крок 2: React рендерить ваші компоненти {/*step-2-react-renders-your-components*/}

Після тригера рендеру React викликає (calls) ваші компоненти, щоб з'ясувати, що виводити на екран. **"Рендеринг" — це коли React викликає ваші компоненти.**

* **Під час початкового рендеру** React викличе кореневий компонент.
* **Для наступних рендерів** React викликатиме функцію компонента, оновлення стану якого власне збудило рендер.

Цей процес є рекурсивним: якщо оновлений компонент повертає якийсь інший компонент, React буде рендерити _цей_ компонент наступним, і якщо цей компонент також щось повертає, він буде рендерити _той інший_ компонент наступним, і так далі. Процес триватиме доти, доки не залишиться вкладених компонентів, і React не знатиме точно, що саме має бути відображено на екрані.

У цьому прикладі React викличе `Gallery()` й `Image()` кілька разів:

<Sandpack>

```js src/Gallery.js active
export default function Gallery() {
  return (
    <section>
      <h1>Скульптури, що надихають</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Рід квіткові' ('Floralis Genérica') — Едуардо Каталано (Eduardo Catalano): велетенська металева скульптура квітки зі світловідбивними пелюстками"
    />
  );
}
```

```js src/index.js
import Gallery from './Gallery.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Gallery />);
```

```css
img { margin: 0 10px 10px 0; }
```

</Sandpack>

* **Під час початкового рендеру** React [створює вузли DOM](https://developer.mozilla.org/docs/Web/API/Document/createElement) для `<section>`, `<h1>` і трьох тегів `<img>`. 
* **Під час повторного рендеру* React вираховує, які властивості елементів змінилися після попереднього рендеру. Він нічого не робить з цією інформацією до наступного кроку, фази коміту.

<Pitfall>

Рендеринг завжди має бути [чистим обчисленням](/learn/keeping-components-pure):

* **Однакові вхідні дані — той самий результат.** З урахуванням однакових вхідних даних чиста функція має завжди повертати той самий JSX. (Коли хтось замовляє салат з помідорами, він не повинен отримати салат з цибулею!)
* **Займається лише своєю справою.** Воно не повинно змінювати жодних об'єктів або змінних, які існували до рендеру. (Замовлення одного не повинно змінювати замовлення інших.)

Інакше ви можете зіткнутися із заплутаними помилками та непередбачуваною поведінкою зі зростанням складності кодової бази. Під час розробки у суворому режимі ("Strict Mode") React викликає функцію кожного компонента двічі, що може допомогти виявити помилки, спричинені нечистими функціями.

</Pitfall>

<DeepDive>

#### Оптимізація продуктивності {/*optimizing-performance*/}

Стандартна поведінка, яка полягає у рендерингу всіх компонентів, вкладених в оновлений компонент, не є оптимальною для продуктивності, якщо оновлений компонент знаходиться дуже високо в дереві. Якщо ви зіткнулися з проблемою продуктивності, є кілька варіантів її вирішення, що наведені в розділі ["Продуктивність"](https://reactjs.org/docs/optimizing-performance.html). **Не оптимізуйте передчасно!**

</DeepDive>

## Крок 3: React вносить зміни в DOM {/*step-3-react-commits-changes-to-the-dom*/}

Після рендерингу (виклику) ваших компонентів React модифікує DOM.

* **Для початкового рендерингу** React використовує API DOM [`appendChild()`](https://developer.mozilla.org/docs/Web/API/Node/appendChild), щоб вивести на екран усі новостворені вузли DOM.
* **Для повторних рендерів** React застосовує мінімально необхідні операції (обчислені під час рендерингу!), щоб оновити DOM відповідно до результату найсвіжішого рендерингу.

**React змінює вузли DOM тільки тоді, коли є різниця між рендерами.** Наприклад, ось компонент, який повторно рендериться щосекунди з різними властивостями, що передаються від батьківського компонента. Зверніть увагу, що можна додати текст у `<input>`, оновивши його `value`, але текст не зникає, коли компонент рендериться повторно:

<Sandpack>

```js src/Clock.js active
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

```js src/App.js hidden
import { useState, useEffect } from 'react';
import Clock from './Clock.js';

function useTime() {
  const [time, setTime] = useState(() => new Date());
  useEffect(() => {
    const id = setInterval(() => {
      setTime(new Date());
    }, 1000);
    return () => clearInterval(id);
  }, []);
  return time;
}

export default function App() {
  const time = useTime();
  return (
    <Clock time={time.toLocaleTimeString()} />
  );
}
```

</Sandpack>

Це працює, тому що на останньому кроці React оновлює лише вміст `<h1>` новим `time`. Він бачить, що `<input>` з'являється у JSX у тому ж місці, що і минулого разу, тому React не чіпає `<input>` або його `value`!
## Епілог: Малювання браузера {/*epilogue-browser-paint*/}

Коли рендеринг завершено і React оновив DOM, браузер перемальовує екран. Хоча цей процес відомий як "рендеринг браузера", ми будемо називати його "малюванням" ("painting"), щоб уникнути плутанини в документації.

<Illustration alt="Картина браузера 'Натюрморт з елементом картки (Сard)'." src="/images/docs/illustrations/i_browser-paint.png" />

<Recap>

* Будь-яке оновлення екрану у React-застосунку відбувається у три кроки:
  1. Тригер
  2. Рендер
  3. Коміт
* Можна скористатися суворим режимом, аби віднайти помилки у компонентах
* React не змінює DOM, якщо результат рендерингу такий самий, як і минулого разу

</Recap>

